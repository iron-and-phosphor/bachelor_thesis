\section{Recommendations}

\subsection{Plans for the type function interpreter}
During this project designs were made for the type function checker. These designs could however not be implemented during the time span of this project. The reason for this is that the type function checker would be the most complex part of the compiler. The type function checker needs to be able to interpret MC on all levels: terms, types and kinds. It would need to be part of the parsing processes or at least heavenly connected to it because type functions, or more precise modules, can be dependent on other type functions that have not been parsed yet. And the only way to parse those depended type functions is to first have its dependencies parsed and typed checked. We have here a circular dependency between the parser, type function checker and the compile time interpreter.
What I would discourage is to make this system monolithic as it would go against the requirements that were set for the rest of the code. What I would suggest is to have the parts in this circular dependency turned into modules and have those modules interface with each other recursively. Those modules would be: A small parser that does not have to identify the function names of the definitions, a type function checker that can identify function names in the definitions and detect if those functions names call to a functions that has already been parsed and lastly an interpreter that works on kind level.
The function checker module would be central in this system because it can decide to both: call the parser if a definition is not parsed yet and call the compile time interpreter to run functions.
I think that a modular system for the type function checker would be needed if the research team wants a simple and maintainable type checker.